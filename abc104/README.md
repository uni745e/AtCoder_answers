# ABC104
https://beta.atcoder.jp/contests/abc104

## B
条件は多いがどれか1つの条件でも満たしていなければWAにするだけ  
ココ最近のB問題では結構難しい


## C All Green
ココ最近のC問題で結構難しい  
Bit全探索を使う。  
1を全問といてボーナスポイントをもらう  
0を1問も解かない  
として得られるスコアと問題を解いた数を計算する。  


その後、スコアが目標得点以下ならば、
全探索時0だった(解かなかった)問題の中で一番得点の大きい問題を
1問以上pi-1問以下解く(中途半端に解く)ことで、
目標得点に達することができるかを判定する。
このとき、中途半端に解く問題は必ず1種類以下になる。
(例：500点問題が6問あるのに5問だけ解いて
400点問題を解き始めるメリットはない。)  
その中で一番解いた問題数が少ないものを出力する。

## D We Love ABC
想定解はDPを使うらしい  
あの問題を見て「よし、DP使おう」とはならない  
今回は累積和を用いて解いた。  

まず、?を使わずにABCを作成するパターンを考える  
Bの位置をj番目に固定した場合(j番目の文字はBか?)、
作れるABCの組み合わせは、  
(1 ~ j - 1までのAの数) * (j + 1 ~ |S|までのCの数)  
となる。

残りの?はA, B, Cの3パターンに変化することが出来るので、
i = jより前の?の数をql, i = j以降の?の数をqrとした時、
最終的に答えは、  
(1 ~ j - 1までのAの数) * (j + 1 ~ |S|までのCの数) * pow(3, ql + qr) % MOD  
となる。

同様に?BC, AB?, ?B?を使ってABCを作るパターンも計算する。

この処理をi = 2 ~ |S| - 1の範囲で行い足し合わせる。

注意  
- AとCで?を使った数だけ指数を引くこと
- Bの位置を変えるたびに冪乗を計算しているとTLE  
    - 予め3^x%MODの結果を用意しておく





## 得た知識  
- bit演算子(<<, >>, &)の使い方

```
a << b : bin(a)を左にb桁シフトして10進数に変換する

# bin(1) -> 10000 -> 2^4 -> 16
range(1 << 4)
>>> range(16)

range(1 << 10)
>>> range(1024)

# range(2 ** N)でいいわ
```

```
a >> b : bin(a)を右にb桁シフトして10進数に変換する
a & 1 : a(int型)のLSBが立っているか判定する

for i in range(d):
    if n >> i & 1:

n = 10 (0b1010)の場合
i = 0 : 10(0b1010) & 1 -> 0
i = 1 : 5(0b101) & 1 -> 1
i = 2 : 2(0b10) & 1 -> 0
i = 3 : 1(0b1) & 1 -> 1
```

- 計算時間  
- \+ < - < * < /  
    - 計算結果を予め用意しておくと掛け算の回数を減らせる  
    ```Python
    pow_three = [1]  
    for i in range(N):
        tmp = pow_three[-1] * 3 % MOD
        pow_three.append(tmp)
    ```