# ABC111
https://beta.atcoder.jp/contests/abc111/tasks

# A - AtCoder Beginner Contest 999
やるだけ

# B - AtCoder Beginner Contest 111
やるだけ

# C - /\\/\\/\\/
遇奇それぞれの出現数を求める  
遇奇それぞれの最頻値をargmaxで求めて、それが同じ数字だった場合  
2番めに多く出現する数字を比較して、書き換え回数が少なくなる方を採用する。

c_2.py : collections.Counterを使った解法

# D - Robot Arms
X + Yの遇奇が全て一致していなければ-1  

## 部分点 d.py  
max(abs(X) + abs(Y))個の長さ1の腕を用意する  

## 満点解法 d_2.py  
2^0, 2^1 ~ 2^kを使えば2^(k + 1) - 1までの全ての奇数を表現できる  
2^0をもう一つ追加してやれば2^(k + 1)までの全ての偶数を表現できる  

制約はX, Y <= 10^9 ≒ 2^30, m <= 40  
XとYそれぞれに対して腕を用意するとなると腕が2*30で60本必要となってしまう  

そこで、x, yの値を両方操作できるようにするために、座標変換を行う。  
u = x + y, v = x - yとして、uv座標系（座標平面が45度回転したようなもの）
を考える。  

こうすることで、2つの値(u, v)を同時に操作でき且つ、uを増やしつつ
vを減らすなどの操作を行える  
R: u + d, v + d  
L: u - d, v - d  
U: u + d, v - d  
D: u - d, v + d

# わかったこと
- 座標変換  
    - xy座標をuv座標（45度回転）させることで問題を簡単に考えることが出来る
- 冪乗関係
    - 10^9 ≒ 2^30  
    - 2^0, 2^1, ..., 2^kで2^(k+1) - 1以下の奇数は全て作れる  
        - 13 = 8 + 4 + 2 - 1  
        - 17 = 16 + 8 - 4 - 2 - 1
    - 偶数の場合は2^0をもう1つ追加するだけ  
        - 14 = 8 + 4 + 2 - 1 + 1
        - 20 = 16 + 8 - 4 - 2 + 1 + 1
- collections.Counter
    - Counter(list)で要素の値と出現回数をカウント
    - C.most_common()で出現回数が多い順にソート